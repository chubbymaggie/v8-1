/*
 * We process the log file generated by V8 --trace-*-internals.
 * We do visualize and data mining on the log file.
 * By richardxx, 2013.7
 */

#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <vector>
#include <map>
#include <set>
#include "options.h"
#include "events.h"

using namespace std;

enum InternalEvent {
#define GetEventName(name, handler) name,
  EVENTS_LIST(GetEventName)
  events_count
#undef GetEventname
};

EventHandler handlers[] = {
#define GetEventHandler(name, handler) handler,
  EVENTS_LIST(GetEventhandler)
  handlers_count
#undef GetEventHandler
};

class State;

struct Transition
{
  State* target;
  int count;
  string* reason;
  
  Transition(): target(NULL), count(0), reason(NULL) {}
};

// Base class for all states
class State 
{
protected:
  Vector<Transition*> trans_all;
  
public:
  State() {
    trans_all.clear();
  }

  virtual bool equals( const State* ) = 0;

  // Search for mergable transitions
  // If not, create a new one
  Transition* transfer(const State* next_state, string reason)
  {
    int i;
    int size = trans_all.size();
    Transition* trans;

    for ( i = 0; i < size; ++i ) {
      trans = trans_all[i];
      if ( trans->target->equals(next_state) )
	break;
    }
    
    if ( i == size ) {
      // We create a new transition
      trans = new Transition;
      trans->target = next_state;
      trans->reason = new string;
    }

    // Record information
    trans->count++;
    trans->reason->append(reason);
    trans->reason->push_back('\n');

    return trans;
  }
};


class FunctionState : public State
{
private:
  int code;
  int shared;


public:
  State():
    code(0),
    shared(0) { }

  void set_code(int new_code) { code = new_code;}
  int get_code() { return code; }

  void set_shared(int new_shared) { shared = new_shared; }
  int get_shared() { return shared; }
  
  bool equals(const State* other) {
    return other->code == code &&
      other->shared == shared;
  }
};


map<int, State*> machines;
FunctionState temp_fstate;
ObjectState 

// Define hanlder prototypes
static void 
create_object(FILE*){}

static void
create_function(FILE*)
{
  int alloc_site;
  int obj_id;
  int source_line;
  State *fsm;

  fscanf( "%d %d %d", &alloc_site,
	  &obj_id, &source_line );
  
  map<int, State*>::iterator it = machines.find(alloc_site);
  if ( it == machines.end() ) {
    // We construct a new machine
    fsm = new FunctionState();
    machines[alloc_site] = fsm;
  }
  else
    fsm = it->second();

  
}



static int 
build_automata()
{
  FILE* file;
  int event_type;
  
  file = fopen( input_file, "r" );
  if ( file == NULL ) return 0;

  while ( fscanf(file, "%d", &event_type) == 1 ) {
    handlers[event_type](file);
  }
}

int main(int argc, char** argv)
{
  if ( parse_options(argc, argv) == 0 )
    return -1;

  if ( build_automata() == 0 ) {
    printf( "Error in the input file, stop.\n" );
    return -1;
  }

  if ( visualize )
    output_graphviz();

  return 0;
}
