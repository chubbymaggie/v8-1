/*
 * We process the log file generated by V8 --trace-*-internals.
 * We do visualize and data mining on the log file.
 * By richardxx, 2013.7
 */

#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <vector>
#include <map>
#include <set>
#include "options.h"
#include "events.h"

using namespace std;


class State;

struct Transition
{
  State* target;
  int count;
  string* reason;
  
  Transition(): target(NULL), count(0), reason(NULL) {}
};

// Base class for all states
class State 
{
protected:
  Vector<Transition*> trans_all;
  
public:
  State() {
    trans_all.clear();
  }

  virtual bool equals( const State* ) = 0;
  virtual State* clone() = 0;

  // Search for mergable transitions
  // If not, create a new one
  State* transfer(const State* next_state, const char* reason)
  {
    int i;
    int size = trans_all.size();
    Transition* trans;

    for ( i = 0; i < size; ++i ) {
      trans = trans_all[i];
      if ( trans->target->equals(next_state) )
	break;
    }
    
    if ( i == size ) {
      // We create a new transition
      trans = new Transition;
      trans->target = next_state->clone();
      trans->reason = new string;
      trans_all->push_back( trans );
    }

    // Record information
    trans->count++;
    trans->reason->append(reason);
    trans->reason->push_back('\n');

    return trans->target;
  }
};


class FunctionState : public State
{
private:
  int code;
  int shared;


public:
  State():
    code(0),
    shared(0) { }

  void set_code(int new_code) { code = new_code;}
  int get_code() { return code; }

  void set_shared(int new_shared) { shared = new_shared; }
  int get_shared() { return shared; }
  
  bool equals(const State* other) {
    return other->code == code &&
      other->shared == shared;
  }
  
  State* clone()
  {
    FunctionState* new_s = new FunctionState;
    new_s->set_code( code );
    new_s->set_shared( shared );
    return new_s;
  }
};


map<int, State*> machines;
map<int, State*> instance_states;
FunctionState fstate_t;


// ---------------------Define hanlder prototypes--------------------
static void 
create_object(FILE*)
{

}

static void
create_function(FILE* file)
{
  int alloc_site;
  int obj_id;
  int source_line;
  int code;
  State *cur_s, *next_s;
  char name_buf[256];


  strcpy( name_buf, "Create Function " );
  fscanf( file, "%d %d %d %d %d %s", 
	  &alloc_site, &obj_id, &source_line,
	  code, 
	  name_buf + strlen(name_buf) );
  
  
  // Lookup the stat machine
  if ( machines.find(alloc_site) == machines.end() ) {
    // We construct a new machine
    cur_s = new FunctionState;
    machines[alloc_site] = cur_s;
  }
  else {
    cur_s = instance_states[obj_id];
  }
  
  // Build a new transition
  fstate_t.set_code(code);
  fstate_t.set_shared(alloc_site);
  next_s = cur_s->transfer( &fstate_t, name_buf );
  instance_states[obj_id] = next_s;
}

static void
change_type(FILE* file)
{
  // To-do
}

static void
expand_array(FILE* file)
{
  // To-do
}

static void
make_hole(FILE* file)
{
  // To-do
}

static void
to_slow_mode(FILE* file)
{
  // To-do
}

static void
array_ops_store_change(FILE* file)
{
  // To-do
}

static void
array_ops_pure(FILE* file)
{
  // To-do
}


static void
install_code(FILE* file, const char* code_desc)
{
  int alloc_site;
  int obj_id;
  int source_line;
  int code;
  State *cur_s, *next_s;


  fscanf( file, "%d %d %d %d %d %s", 
	  &alloc_site, &obj_id, &source_line,
	  code );
  
  
  // Lookup the stat machine
  if ( machines.find(alloc_site) == machines.end() ) {
    // We construct a new machine
    cur_s = new FunctionState;
    machines[alloc_site] = cur_s;
  }
  else {
    cur_s = instance_states[obj_id];
  }
  
  // Build a new transition
  fstate_t.set_code(code);
  fstate_t.set_shared(alloc_site);
  next_s = cur_s->transfer( &fstate_t, code_desc );
  instance_states[obj_id] = next_s;
}

static void
gen_full_code(FILE* file)
{
  install_code(file, "Full" );
}

static void
gen_opt_code(FILE* file)
{
  install_code(file, "Optimize" );
}

static void
gen_osr_code(FILE* file)
{
  install_code(file, "OSR" );
}

// ---------------------------
enum InternalEvent {
#define GetEventName(name, handler) name,
  EVENTS_LIST(GetEventName)
  events_count
#undef GetEventname
};

EventHandler handlers[] = {
#define GetEventHandler(name, handler) handler,
  EVENTS_LIST(GetEventhandler)
  handlers_count
#undef GetEventHandler
};


static int 
build_automata()
{
  FILE* file;
  int event_type;
  
  file = fopen( input_file, "r" );
  if ( file == NULL ) return 0;

  while ( fscanf(file, "%d", &event_type) == 1 ) {
    handlers[event_type](file);
  }
}

static void
output_graphviz()
{
  map<int,State*>::iterator it = machines.begin();

  while ( it != machines.end() ) {
    State* fsm = it->second();
    
  }
}


int main(int argc, char** argv)
{
  if ( parse_options(argc, argv) == 0 )
    return -1;

  if ( build_automata() == 0 ) {
    printf( "Error in the input file, stop.\n" );
    return -1;
  }

  if ( visualize )
    output_graphviz();

  return 0;
}
