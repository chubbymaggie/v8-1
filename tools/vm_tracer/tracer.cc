/*
 * We process the log file generated by V8 --trace-*-internals.
 * We do visualize and data mining on the log file.
 * By richardxx, 2013.7
 */

#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <string>
#include <queue>
#include "options.h"
#include "events.h"
#include "state_machine.h"


// Globals
map<int, StateMachine*> machines;


// Create a state transition
State* 
transfer(StateMachine* fsm, 
	 State* cur_s, State* next_s, 
	 const char* desc)
{
  Transition* trans;
  
  // Search for the same state
  trans = cur_s->find_transition(next_s);
  
  if ( trans == NULL ) {
    // Not exist
    // We try to search and add to the state machine pool
    next_s = fsm->search_state(next_s);
    trans = cur_s->add_transition(next_s);
  }
  else {
    next_s = trans->target;
  }
  
  trans->count++;
  trans->insert_reason(desc);
  return next_s;
}


StateMachine* 
find_machine(int m_sig, StateMachine::Mtype type)
{
  StateMachine* fsm = NULL;
  map<int, StateMachine*>::iterator i_fsm = machines.find(m_sig);

  if ( i_fsm != machines.end() ) {
    fsm = i_fsm->second;
  }
  else{
    if ( type == StateMachine::Mtype::Function )
      fsm = new FunctionMachine;
    else
      fsm = new ObjectMachine;
    
    machines[m_sig] = fsm;
  }
  
  return fsm;
}


StateMachine*
install_code( StateMachine* fsm,
	      int func, int code, const char* trans_desc)
{
  static FunctionState fstate_t(0);
  FunctionState *cur_s, *next_s;
  
  // Obtain current position of this function
  cur_s = (FunctionState*)fsm->get_instance_pos(func);
  
  // Build the target state
  fstate_t.code = (code == -1 ? cur_s->code : code);
   
  // Transfer state
  next_s = 
    (FunctionState*)transfer( fsm, cur_s, &fstate_t, trans_desc );
  fsm->instance_walk_to(func, next_s);

  return fsm;
}


// ---------------------Define hanlder prototypes--------------------
static void 
create_object(FILE*)
{
  // To do..
}


static void
create_function(FILE* file)
{
  int shared;
  int func;
  int code;
  char name_buf[256];


  fscanf( file, "%p %d %p %s", 
	  &shared, &func, &code, 
	  name_buf );
  
  StateMachine* fsm = find_machine(shared,
				   StateMachine::Mtype::Function);
  fsm->set_machine_name( name_buf );
  install_code(fsm, func, code, "New");  
}

static void
change_type(FILE* file)
{
  // To-do
}

static void
expand_array(FILE* file)
{
  // To-do
}

static void
make_hole(FILE* file)
{
  // To-do
}

static void
to_slow_mode(FILE* file)
{
  // To-do
}

static void
array_ops_store_change(FILE* file)
{
  // To-do
}

static void
array_ops_pure(FILE* file)
{
  // To-do
}

static void
gen_full_code(FILE* file)
{
  int shared, func, code;
  fscanf( file, "%p %d %p", &shared, &func, &code );
  
  StateMachine* fsm = find_machine(shared,
				   StateMachine::Mtype::Function);
  install_code( fsm, func, code, "Full" );
}

static void
gen_full_deopt(FILE* file)
{
  int shared, func, old_code, new_code;
  fscanf( file, "%p %d %p %p", 
	  &shared, &func, 
	  &old_code, &new_code );
  
  StateMachine* fsm = find_machine(shared,
				   StateMachine::Mtype::Function);
  install_code( fsm, func, new_code, "AddDeopt" );
}

static void
gen_opt_code(FILE* file)
{
  int shared, func, code;
  char opt_buf[128];
  
  sprintf( opt_buf, "Opt: " );
  fscanf( file, "%p %d %p %s", 
	  &shared, &func, &code, 
	  opt_buf + strlen(opt_buf) );

  StateMachine* fsm = find_machine(shared,
				   StateMachine::Mtype::Function);
  install_code( fsm, func, code, opt_buf );
}

static void
gen_osr_code(FILE* file)
{
  int shared, func, code;
  char opt_buf[128];

  sprintf( opt_buf, "Osr: " );
  fscanf( file, "%p %d %p %s",
          &shared, &func, &code, opt_buf + strlen(opt_buf) );

  StateMachine* fsm = find_machine(shared,
				   StateMachine::Mtype::Function);
  install_code( fsm, func, code, opt_buf );
}

static void
disable_opt(FILE* file)
{
  int shared, func;
  char opt_buf[128];

  fscanf( file, "%p %d %[^\t\n]",
          &shared, &func, opt_buf );

  FunctionMachine* fsm = 
    (FunctionMachine*)find_machine(shared, StateMachine::Mtype::Function);
  fsm->set_opt_state( false, opt_buf );
}

static void
reenable_opt(FILE* file)
{
  int shared, func;
  char opt_buf[128];

  fscanf( file, "%p %d %[^\t\n]",
          &shared, &func, opt_buf );

  FunctionMachine* fsm = 
    (FunctionMachine*)find_machine(shared, StateMachine::Mtype::Function);
  fsm->set_opt_state( true, opt_buf );
}

static void
gen_opt_failed(FILE* file)
{
  int shared, func;
  char opt_buf[128];

  sprintf( opt_buf, "OptFailed: " );
  int last_pos = strlen(opt_buf);

  fscanf( file, "%p %d %[^\t\n]",
          &shared, &func, opt_buf + last_pos );

  FunctionMachine* fsm = 
    (FunctionMachine*)find_machine(shared, StateMachine::Mtype::Function);

  if ( opt_buf[last_pos] == '-' &&
       opt_buf[last_pos+1] == '\0' ) {
    // Reuse the disable message
    sprintf( opt_buf+last_pos, "%s", fsm->optMsg.c_str() );
  }

  install_code( fsm, func, -1, opt_buf );
}

static void
deopt_code(FILE* file)
{
  int shared, func, code;
  char opt_buf[128];
  
  sprintf( opt_buf, "Deopt: " );
  fscanf( file, "%p %d %p %s", 
	  &shared, &func, &code, 
	  opt_buf + strlen(opt_buf) );

  StateMachine* fsm = find_machine(shared,
				   StateMachine::Mtype::Function);
  install_code( fsm, func, code, opt_buf );
}

static void
null_handler(FILE* file)
{

}

// ---------------------------
enum InternalEvent {
#define GetEventName(name, handler) name,
  EVENTS_LIST(GetEventName)
  events_count
#undef GetEventname
};

EventHandler handlers[] = {
#define GetEventHandler(name, handler) handler,
  EVENTS_LIST(GetEventHandler)
  null_handler
#undef GetEventHandler
};


static int 
build_automata()
{
  FILE* file;
  int event_type;
  
  file = fopen( input_file, "r" );
  if ( file == NULL ) return 0;

  while ( fscanf(file, "%d", &event_type) == 1 ) {
    handlers[event_type](file);
  }
  
  fclose(file);
  return 1;
}

static void
output_graphviz()
{
  FILE* file;
  int n_graph;
  int n_states;
  queue<State*> bfsQ;
  set<State*> visited;

  file = fopen(visual_file, "w");
  if ( file == NULL ) {
    fprintf(stderr, "Cannot create visualization file %s\n", visual_file);
    return;
  }

  // Do BFS to draw graph
  n_graph = 0;
  for ( map<int,StateMachine*>::iterator it = machines.begin();
	it != machines.end();
	++it ) {
    StateMachine* fsm = it->second;
    if ( fsm->size() < 4 ) continue;

    State* init_state = fsm->start;
    fprintf(file, "digraph G%d {\n", n_graph);
    ++n_graph;
    
    // Go over the state machine
    visited.clear();
    visited.insert(init_state);
    bfsQ.push(init_state);

    while ( !bfsQ.empty() ) {
      State* cur_s = bfsQ.front();
      bfsQ.pop();
      
      // We first generate the node description
      int id;
      
      if ( cur_s == init_state ) {
	id = 0;
	fprintf(file, 
		"\t0 [shape=ellipse, peripheries=2, label=\"%s\"];\n",
		fsm->machine_name.c_str() );
      }
      else {
	id = cur_s->id;
	fprintf(file, 
		"\t%d [shape=box, label=\"%s\"];\n", 
		id, 
		cur_s->descriptor().c_str());
      }
      
      // We draw the transition edges
      State::TransIterator it = cur_s->begin();
      State::TransIterator end = cur_s->end();
      for ( ;
	    it != end; ++it ) {
	Transition* trans = it->second;
	State* next_s = trans->target;
	if ( visited.find(next_s) == visited.end() ) {
	  bfsQ.push(next_s);
	  visited.insert(next_s);
	}
	
	// Generate the transition descriptive string
	string* reason = trans->merge_reasons();
	const char* desc = NULL;
	if ( trans->count == 1 )
	  desc = "\t%d -> %d [label=\"%s\"];\n";
	else
	  desc = "\t%d -> %d [label=\"%s//%dX\"];\n";

	fprintf(file, 
		desc,
		id, next_s->id, 
		reason->c_str(),
		trans->count);

	delete reason;
      }
    }

    fprintf(file, "}\n\n");
  }
  
  fclose(file);
}


int main(int argc, char** argv)
{
  if ( parse_options(argc, argv) == 0 )
    return -1;

  if ( build_automata() == 0 ) {
    printf( "Error in the input file, stop.\n" );
    return -1;
  }

  if ( visual_file != NULL )
    output_graphviz();

  return 0;
}
