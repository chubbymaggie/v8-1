/*
 * We process the log file generated by V8 --trace-*-internals.
 * We do visualize and data mining on the log file.
 * By richardxx, 2013.7
 */

#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <string>
#include <queue>
#include "options.h"
#include "events.h"
#include "state_machine.h"


enum InternalEvent {
#define GetEventName(name, handler) name,
  EVENTS_LIST(GetEventName)
  events_count
#undef GetEventname
};


// Handler declarations
#define DeclEventHanlder(name, handler) \
  static void handler(FILE*);

EVENTS_LIST(DeclEventHanlder)

static void
null_handler(FILE* file) { }

#undef DeclEventHandler

// Fill in the hanlder list
EventHandler handlers[] = {
#define GetEventHandler(name, handler) handler,
  EVENTS_LIST(GetEventHandler)
  null_handler
#undef GetEventHandler
};

FunctionMachine::CodeStatesMap* FunctionMachine::code_in;

// From machine ID to machine structure
map<int, StateMachine*> machines;
// From function address to function id
map<int, int> functions;
int func_id_counter = 0;


static
void init_machines()
{
  FunctionMachine::code_in = new FunctionMachine::CodeStatesMap;
}

static
void clean_machines()
{
  delete FunctionMachine::code_in;
}


// Create a state transition
State* 
transfer(StateMachine* fsm, 
	 State* cur_s, State* next_s, 
	 const char* desc)
{
  Transition* trans;
  
  // Search for the same state
  trans = cur_s->find_transition(next_s);
  
  if ( trans == NULL ) {
    // Not exist
    // We try to search and add to the state machine pool
    next_s = fsm->search_state(next_s);
    trans = cur_s->add_transition(next_s);
  }
  else {
    next_s = trans->target;
  }
  
  trans->count++;
  trans->insert_reason(desc);
  return next_s;
}


StateMachine* 
find_machine(int m_sig, StateMachine::Mtype type)
{
  StateMachine* fsm = NULL;
  map<int, StateMachine*>::iterator i_fsm = machines.find(m_sig);

  if ( i_fsm != machines.end() ) {
    fsm = i_fsm->second;
  }
  else{
    if ( type == StateMachine::Function )
      fsm = new FunctionMachine;
    else
      fsm = new ObjectMachine;
    
    machines[m_sig] = fsm;
  }
  
  return fsm;
}

int
get_function_id(int f_addr)
{
  map<int, int>::iterator it = functions.find(f_addr);
  if ( it == functions.end() ) {
    // Never seen this function before
    return -1;
  }

  return it->second;
}


void
replace_code( StateMachine* fsm,
	      int func, int code, const char* trans_desc)
{
  static FunctionState fstate_t(0);
  FunctionState *cur_s, *next_s;
  
  int func_id = get_function_id(func);

  if ( func_id != -1 ) {
    // Obtain current position of this function
    cur_s = (FunctionState*)fsm->get_instance_pos(func_id);
    
    // Build the target state
    fstate_t.code = (code == -1 ? cur_s->code : code);
    fstate_t.machine = fsm;

    // Transfer state
    next_s = 
      (FunctionState*)transfer( fsm, cur_s, &fstate_t, trans_desc );

    // Renew the position of this function
    fsm->instance_walk_to(func_id, next_s);
  }
}


// ---------------------Define hanlder prototypes--------------------
static void 
create_object(FILE*)
{
  // To do..
}


static void
create_function(FILE* file)
{
  int shared;
  int func;
  int code;
  char name_buf[256];


  fscanf( file, "%p %p %p %[^\t\n]", 
	  &shared, &func, &code, 
	  name_buf );
  
  StateMachine* fsm = find_machine(shared,
				   StateMachine::Function);
  if ( fsm->has_no_name() ) {
    fsm->set_machine_name( name_buf );
  }

  functions[func] = func_id_counter++;
  replace_code(fsm, func, code, "New");
  
  if ( slice_sig == shared ) {
    printf( "%d %p %p %p %s",
	    InternalEvent::CreateFunction,
	    shared, func, code, name_buf );
  }
}

static void
gc_move_function(FILE* file)
{
  int from, to;
  fscanf( file, "%p %p", &from, &to );
  
  // Replace the function to function_ID map
  int id = 0;
  map<int, int>::iterator it = functions.find(from);
  if ( it == functions.end() )
    id = func_id_counter++;
  else {
    id = it->second;
    functions.erase(it);
  }
  
  functions[to] = id;
}

static void
gc_move_shared(FILE* file)
{
  int from, to;
  fscanf( file, "%p %p", &from, &to );

  map<int, StateMachine*>::iterator i_fsm = machines.find(from);  
  if ( i_fsm != machines.end() ) {
    StateMachine* fsm = i_fsm->second;
    machines.erase(i_fsm);
    machines[to] = fsm;
  }
}

static void
gc_move_code(FILE* file)
{
  int old_code, new_code;
  fscanf( file, "%p %p", 
	  &old_code, &new_code );

  FunctionMachine::CodeStatesMap* code_in = FunctionMachine::code_in;
  FunctionMachine::CodeStatesMap::iterator it = code_in->find(old_code);
  if ( it == code_in->end() ) return;

  vector<FunctionState*> *old_states = it->second;
  int size = old_states->size();
  vector<FunctionState*> *new_states = new vector<FunctionState*>(size);

  for ( int i = 0; i < size; ++i ) {
    FunctionState* fs = old_states->at(i);
    
    // We create a new state and a state transition
    StateMachine* fsm = fs->machine;
    fs->code = new_code;
    State* new_fs = fsm->insert_new_state(fs);
    fs->code = old_code;
    transfer( fsm, fs, new_fs, "GC Code");
    
    // We move all the instances to the new state
    for ( set<int>::iterator it = fs->instances.begin(),
	    end = fs->instances.end();
	  it != end; ++it ) {
      int func_id = *it;
      fsm->instance_walk_to(func_id, new_fs);
    }

    new_states->push_back((FunctionState*)new_fs);
  }

  //code_in->erase(it);
  (*code_in)[new_code] = new_states;
}

static void
change_type(FILE* file)
{
  // To-do
}

static void
expand_array(FILE* file)
{
  // To-do
}

static void
make_hole(FILE* file)
{
  // To-do
}

static void
to_slow_mode(FILE* file)
{
  // To-do
}

static void
array_ops_store_change(FILE* file)
{
  // To-do
}

static void
array_ops_pure(FILE* file)
{
  // To-do
}

static void
install_code(FILE* file)
{
  int shared, func, code;
  fscanf( file, "%p %p %p",
          &shared, &func, &code );
  
  StateMachine* fsm = find_machine(shared,
                                   StateMachine::Function);
  replace_code( fsm, func, code, "Install" );
}

static void
gen_full_code(FILE* file)
{
  int shared, func, code;
  fscanf( file, "%p %p %p", 
	  &shared, &func, &code );
  
  StateMachine* fsm = find_machine(shared,
				   StateMachine::Function);
  replace_code( fsm, func, code, "Full" );
}

static void
gen_full_deopt(FILE* file)
{
  int shared, func, old_code, new_code;
  fscanf( file, "%p %p %p %p", 
	  &shared, &func, 
	  &old_code, &new_code );
  
  StateMachine* fsm = find_machine(shared,
				   StateMachine::Function);
  replace_code( fsm, func, new_code, "AddDeopt" );
}

static void
gen_opt_code(FILE* file)
{
  int shared, func, code;
  char opt_buf[128];
  
  sprintf( opt_buf, "Opt: " );
  fscanf( file, "%p %p %p %[^\t\n]", 
	  &shared, &func, &code, 
	  opt_buf + strlen(opt_buf) );

  StateMachine* fsm = find_machine(shared,
				   StateMachine::Function);
  replace_code( fsm, func, code, opt_buf );
}

static void
gen_osr_code(FILE* file)
{
  int shared, func, code;
  char opt_buf[128];

  sprintf( opt_buf, "Osr: " );
  fscanf( file, "%p %p %p %[^\t\n]",
          &shared, &func, &code, opt_buf + strlen(opt_buf) );

  StateMachine* fsm = find_machine(shared,
				   StateMachine::Function);
  replace_code( fsm, func, code, opt_buf );
}

static void
disable_opt(FILE* file)
{
  int shared, func;
  char opt_buf[128];

  fscanf( file, "%p %p %[^\t\n]",
          &shared, &func, opt_buf );

  FunctionMachine* fsm = 
    (FunctionMachine*)find_machine(shared, StateMachine::Function);
  fsm->set_opt_state( false, opt_buf );
}

static void
reenable_opt(FILE* file)
{
  int shared, func;
  char opt_buf[128];

  fscanf( file, "%p %p %[^\t\n]",
          &shared, &func, opt_buf );

  FunctionMachine* fsm = 
    (FunctionMachine*)find_machine(shared, StateMachine::Function);
  fsm->set_opt_state( true, opt_buf );
}

static void
gen_opt_failed(FILE* file)
{
  int shared, func;
  char opt_buf[128];

  sprintf( opt_buf, "OptFailed: " );
  int last_pos = strlen(opt_buf);

  fscanf( file, "%p %p %[^\t\n]",
          &shared, &func, opt_buf + last_pos );

  FunctionMachine* fsm = 
    (FunctionMachine*)find_machine(shared, StateMachine::Function);

  if ( opt_buf[last_pos] == '-' &&
       opt_buf[last_pos+1] == '\0' ) {
    // Reuse the disable message
    sprintf( opt_buf+last_pos, "%s", fsm->optMsg.c_str() );
  }

  replace_code( fsm, func, -1, opt_buf );
}

static void
deopt_code(FILE* file)
{
  int shared, func, code;
  char opt_buf[128];
  
  sprintf( opt_buf, "Deopt: " );
  fscanf( file, "%p %p %p %s", 
	  &shared, &func, &code, 
	  opt_buf + strlen(opt_buf) );

  StateMachine* fsm = find_machine(shared,
				   StateMachine::Function);
  replace_code( fsm, func, code, opt_buf );
}


// -----------------system functions---------------
static void
output_graphviz()
{
  FILE* file;
  int n_graph;
  int n_states;
  queue<State*> bfsQ;
  set<State*> visited;

  file = fopen(visual_file, "w");
  if ( file == NULL ) {
    fprintf(stderr, "Cannot create visualization file %s\n", visual_file);
    return;
  }

  //printf( "count machines = %d\n", machines.size() );

  // Do BFS to draw graph
  n_graph = 0;
  for ( map<int,StateMachine*>::iterator it = machines.begin();
	it != machines.end();
	++it ) {
    StateMachine* fsm = it->second;
    if ( fsm->size() < states_count_limit ) continue;
    if ( fsm->has_no_name() ) continue;

    State* init_state = fsm->start;
    fprintf(file, "digraph G%d {\n", n_graph);
    ++n_graph;
    
    // Go over the state machine
    visited.clear();
    visited.insert(init_state);
    bfsQ.push(init_state);

    while ( !bfsQ.empty() ) {
      State* cur_s = bfsQ.front();
      bfsQ.pop();
      
      // We first generate the node description
      int id;
      
      if ( cur_s == init_state ) {
	id = 0;
	fprintf(file, 
		"\t0 [shape=ellipse, peripheries=2, label=\"%s\"];\n",
		fsm->m_name.c_str() );
      }
      else {
	id = cur_s->id;
	fprintf(file, 
		"\t%d [shape=box, label=\"%s\"];\n", 
		id, 
		cur_s->descriptor().c_str());
      }
      
      // We draw the transition edges
      State::TransIterator it = cur_s->begin();
      State::TransIterator end = cur_s->end();
      for ( ;
	    it != end; ++it ) {
	Transition* trans = it->second;
	State* next_s = trans->target;
	if ( visited.find(next_s) == visited.end() ) {
	  bfsQ.push(next_s);
	  visited.insert(next_s);
	}
	
	// Generate the transition descriptive string
	string* reason = trans->merge_reasons();
	const char* desc = NULL;
	if ( trans->count == 1 )
	  desc = "\t%d -> %d [label=\"%s\"];\n";
	else
	  desc = "\t%d -> %d [label=\"%s//%dX\"];\n";

	fprintf(file, 
		desc,
		id, next_s->id, 
		reason->c_str(),
		trans->count);

	delete reason;
      }
    }

    fprintf(file, "}\n\n");
  }
  
  fclose(file);
}

static int 
build_automata()
{
  FILE* file;
  int event_type;
  
  file = fopen( input_file, "r" );
  if ( file == NULL ) return 0;

  init_machines();

  while ( fscanf(file, "%d", &event_type) == 1 ) {
    handlers[event_type](file);
  }
  
  fclose(file);
  
  clean_machines();

  return 1;
}


int main(int argc, char** argv)
{
  if ( parse_options(argc, argv) == 0 )
    return -1;

  if ( build_automata() == 0 ) {
    printf( "Error in the input file, stop.\n" );
    return -1;
  }

  if ( visual_file != NULL )
    output_graphviz();

  return 0;
}
